# Sinilink / Drok XY-SK150S Buck-Boost Power Supply (Modbus) – ESPHome Config
substitutions:
  model: "XY-SK150S"
  short_model: "xysk150s"

  device_name: "sinilink-xy-sk150s-psu"
  device_friendly_name: "Sinilink XY-SK150S PSU"
  device_description: "Sinilink XY-SK150S Buck-Boost Power Supply"

  voltage_max: "40.00"
  current_max: "8.000"
  power_max: "150.0"

  voltage_resolution: "0.01"
  current_resolution: "0.001"
  voltage_accuracy_decimals: "2"
  current_accuracy_decimals: "3"

  modbus_address: "0x01"
  modbus_baud: "115200"   # Change to 9600 if needed.

  ip_report_interval: "5s"
  wifi_read_interval: "1s"
  logic_interval: "500ms"

  undervoltage_cutoff: "0.0"   # Set to 0 (or a suitable value e.g. 11.2) for 12V ATX PSU.

  project_version: "1.0.0-sk150s"

globals:
  - id: vin_undervoltage_theshold
    type: float
    restore_value: no
    initial_value: ${undervoltage_cutoff}

esphome:
  name: ${device_name}
  friendly_name: ${device_friendly_name}
  comment: ${device_description}
  name_add_mac_suffix: false
  project:
    name: "sinilink.${short_model}"
    version: ${project_version}
  on_boot:
    priority: -100
    then:
      - lambda: |-
          ESP_LOGI("boot", "Startup safety: Forcing output OFF.");
      - if:
          condition:
            switch.is_on: output_switch
          then:
            - switch.turn_off: output_switch
      - delay: 500ms
      - if:
          condition:
            switch.is_on: out_relay
          then:
            - switch.turn_off: out_relay

esp8266:
  board: esp01_1m

logger:
  level: INFO
  baud_rate: 0   # Disable UART logging (UART used by Modbus)

api:
  encryption:
    key: !secret default_native_api_encryption_key
  reboot_timeout: 0s

ota:
  - platform: esphome
    id: my_ota
    password: !secret default_ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Sinilink-Xy-Sk150S Fallback AP"
    password: !secret fallback_ap_password

captive_portal:

status_led:
  pin:
    number: GPIO2
    inverted: true

web_server:
  port: 80
  local: true
  log: false

uart:
  id: mod_bus
  tx_pin: GPIO1
  rx_pin: GPIO3
  baud_rate: ${modbus_baud}
  data_bits: 8
  stop_bits: 1
  parity: NONE

modbus:
  id: modbus1

modbus_controller:
  - id: powersupply
    address: ${modbus_address}
    modbus_id: modbus1
    setup_priority: 600
    update_interval: 1s
    command_throttle: 1ms

# TEXT SENSORS
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "${device_friendly_name} IP"
      id: ip_address
    ssid:
      name: "Connected SSID"
      id: connected_ssid

  - platform: template
    name: "Turn On Time"
    icon: mdi:timer-outline
    lambda: |-
      char buffer[16];
      snprintf(buffer, sizeof(buffer), "%02d:%02d:%02d",
               (int)id(turnon_hours).state,
               (int)id(turnon_minutes).state,
               (int)id(turnon_seconds).state);
      return std::string(buffer);
    update_interval: 1s

  - platform: version
    name: "ESPHome Version"
    entity_category: diagnostic

# PERIODIC TASKS / LOGIC
interval:
  - interval: ${ip_report_interval}
    then:
      - lambda: |-
          if (id(ip_address).state.empty()) return;
          char ip[18];
          strncpy(ip, id(ip_address).state.c_str(), 17);
          ip[17] = 0;
          char *ptr = ip;
          int ip1 = atoi(ptr);
          ptr = strchr(ptr, '.'); if (!ptr) return;
          int ip2 = atoi(++ptr);
          ptr = strchr(ptr, '.'); if (!ptr) return;
          int ip3 = atoi(++ptr);
          ptr = strchr(ptr, '.'); if (!ptr) return;
          int ip4 = atoi(++ptr);

          auto *controller = id(powersupply);
          std::vector<uint16_t> wifi_data = {
            0x3b3a,
            2,
            4,
            uint16_t((ip1 << 8) | ip2),
            uint16_t((ip3 << 8) | ip4)
          };
          auto cmd = esphome::modbus_controller::ModbusCommandItem::create_write_multiple_command(
                controller, 0x30, 5, wifi_data);
          controller->queue_command(cmd);

  - interval: ${wifi_read_interval}
    then:
      - lambda: |-
          auto *controller = id(powersupply);
          auto cmd = esphome::modbus_controller::ModbusCommandItem::create_read_command(
              controller,
              esphome::modbus_controller::ModbusRegisterType::HOLDING,
              0x30, 5);
          controller->queue_command(cmd);

  - interval: ${logic_interval}
    then:
      - lambda: |-
          static int undercurrent_count = 0;
          static int relay_delay_count = 0;
          static int uv_sample_count = 0;

          // Under-current cutoff logic
          if (id(output_switch).state &&
              (id(cutoff_current).state != 0) &&
              (id(output_current).state < id(cutoff_current).state)) {
            if (undercurrent_count >= 5) {
              undercurrent_count = 0;
              id(output_switch).turn_off();
              id(out_relay).turn_off();
              ESP_LOGI("logic", "Cutoff: Output disabled due to undercurrent.");
            } else {
              undercurrent_count++;
            }
          } else {
            undercurrent_count = 0;
          }

          // Input undervoltage detection
          if (id(vin_undervoltage_theshold) > 0) {   // <-- Guard (set threshold 0 to disable)
            if (id(input_voltage).state < id(vin_undervoltage_theshold)) {
              if (uv_sample_count < 4) uv_sample_count++;
            } else {
              if (id(output_switch).state) id(out_relay).turn_on();
              uv_sample_count = 0;
            }
            if (uv_sample_count >= 4) {
              id(out_relay).turn_off();
            }
          } else {
            uv_sample_count = 0;
          }

          // Relay inactivity timeout
          if (id(out_relay).state) {
            if (id(output_switch).state) relay_delay_count = 0;
            else relay_delay_count++;
          } else {
            relay_delay_count = 0;
          }
          if (relay_delay_count >= 120 * 3) {
            id(out_relay).turn_off();
            relay_delay_count = 0;
            ESP_LOGI("logic", "Relay off due to inactivity timeout.");
          }

# SENSORS (Power Supply + Diagnostics)
sensor:
  - platform: modbus_controller
    modbus_controller_id: powersupply
    address: 2
    name: "Output Voltage"
    device_class: voltage
    state_class: measurement
    unit_of_measurement: "V"
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: ${voltage_accuracy_decimals}
    filters:
      - multiply: ${voltage_resolution}

  - platform: modbus_controller
    modbus_controller_id: powersupply
    address: 3
    name: "Output Current"
    id: output_current
    device_class: current
    state_class: measurement
    unit_of_measurement: "A"
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: ${current_accuracy_decimals}
    filters:
      - multiply: ${current_resolution}

  - platform: modbus_controller
    modbus_controller_id: powersupply
    address: 4
    name: "Output Power"
    device_class: power
    state_class: measurement
    unit_of_measurement: "W"
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: powersupply
    address: 5
    name: "Input Voltage"
    id: input_voltage
    device_class: voltage
    state_class: measurement
    unit_of_measurement: "V"
    register_type: holding
    value_type: U_WORD
    accuracy_decimals: ${voltage_accuracy_decimals}
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: powersupply
    address: 6
    name: "Battery Charge"
    device_class: energy_storage
    state_class: measurement
    unit_of_measurement: "Ah"
    icon: mdi:battery-60
    register_type: holding
    value_type: U_DWORD_R
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: powersupply
    address: 8
    name: "Battery Energy"
    device_class: energy_storage
    state_class: measurement
    unit_of_measurement: "Wh"
    icon: mdi:battery-60
    register_type: holding
    value_type: U_DWORD_R
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: powersupply
    address: 10
    name: "turnon_hours"
    id: turnon_hours
    unit_of_measurement: "h"
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: powersupply
    address: 11
    name: "turnon_minutes"
    id: turnon_minutes
    unit_of_measurement: "min"
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    modbus_controller_id: powersupply
    address: 12
    name: "turnon_seconds"
    id: turnon_seconds
    unit_of_measurement: "s"
    register_type: holding
    value_type: U_WORD
    internal: true

  - platform: modbus_controller
    name: "Internal Temperature"
    device_class: temperature
    state_class: measurement
    modbus_controller_id: powersupply
    register_type: holding
    address: 13
    value_type: S_WORD
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    name: "External Temperature"
    device_class: temperature
    state_class: measurement
    modbus_controller_id: powersupply
    register_type: holding
    address: 14
    value_type: S_WORD
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    filters:
      - multiply: 0.1

  - platform: modbus_controller
    name: "Host Type"
    modbus_controller_id: powersupply
    register_type: holding
    address: 48
    value_type: U_WORD
    internal: true

  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_db
    update_interval: 60s
    device_class: signal_strength
    entity_category: diagnostic

  - platform: copy
    source_id: wifi_signal_db
    name: "WiFi Signal Percent"
    filters:
      - lambda: return std::min(std::max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "%"
    device_class: signal_strength
    entity_category: diagnostic

  # only works on esp32 :(
  # - platform: internal_temperature
  #   name: "ESP MCU Temperature"
  #   update_interval: 60s
  #   entity_category: diagnostic

  - platform: uptime
    name: "Uptime"
    update_interval: 1200s
    entity_category: diagnostic
    filters:
      - lambda: return x / 3600.0;
    unit_of_measurement: "h"

# BINARY SENSORS
binary_sensor:
  - platform: modbus_controller
    modbus_controller_id: powersupply
    name: "Constant Voltage Mode"
    address: 17
    register_type: holding
    bitmask: 0x1
    filters:
      - invert:
  - platform: modbus_controller
    modbus_controller_id: powersupply
    name: "Constant Current Mode"
    address: 17
    register_type: holding
    bitmask: 0x1

# NUMBERS (Writable Setpoints)
number:
  - platform: modbus_controller
    modbus_controller_id: powersupply
    name: "Set Output Voltage"
    id: set_output_voltage
    device_class: voltage
    unit_of_measurement: "V"
    entity_category: config
    mode: box
    address: 0
    value_type: U_WORD
    min_value: 0
    max_value: ${voltage_max}
    step: ${voltage_resolution}
    lambda: !lambda |-
      return x * ${voltage_resolution};
    write_lambda: !lambda |-
      return x / ${voltage_resolution};

  - platform: modbus_controller
    modbus_controller_id: powersupply
    name: "Set Output Current"
    id: set_output_current
    device_class: current
    unit_of_measurement: "A"
    entity_category: config
    mode: box
    address: 1
    value_type: U_WORD
    min_value: 0
    max_value: ${current_max}
    step: ${current_resolution}
    lambda: !lambda |-
      return x * ${current_resolution};
    write_lambda: !lambda |-
      return x / ${current_resolution};

  - platform: template
    name: "Under-Current Cutoff"
    id: cutoff_current
    device_class: current
    unit_of_measurement: "A"
    entity_category: config
    mode: box
    min_value: 0
    max_value: ${current_max}
    step: ${current_resolution}
    optimistic: true
    icon: mdi:current-ac

# SWITCHES
switch:
  - platform: modbus_controller
    modbus_controller_id: powersupply
    name: "Output Enable"
    id: output_switch
    address: 18
    register_type: holding
    bitmask: 0x1
    entity_category: config
    icon: mdi:power

  - platform: gpio
    id: out_relay
    name: "Output Relay"
    pin:
      number: GPIO4
      inverted: false
    restore_mode: ALWAYS_OFF
    icon: mdi:relay