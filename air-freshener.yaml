substitutions:
  # Adjustable timings and options
  spray_default_interval: "35"      # in minutes
  spray_min_interval: "5"           # in minutes
  spray_max_interval: "60"          # in minutes
  spray_step: "5"                   # in minutes
  pre_spray_warning_seconds: "10"   # seconds before spray to start warning
  fast_flash_count: "8"             # red flashes before spray
  fast_flash_interval_ms: "200"     # ms between fast red flashes
  spray_duration_ms: "400"          # motor on-time
  time_update_interval: "15"        # sensor update in seconds
  night_start: "21"                 # disable spray after this time
  night_end: "6"                    # resume spray after this time
  led_max_brightness: "0.1"         # 0.0-1.0 PWM level
  motor_pin: D1                     
  led_red_pin: D5                   
  led_green_pin: D6
  led_blue_pin: D7
  physical_manual_spray_btn_pin: D3

esphome:
  name: air-freshener
  friendly_name: "Air Freshener"
  on_boot:
    - priority: 800
      then: 
        - output.set_level:
            id: led_blue
            level: ${led_max_brightness}
    - priority: 300
      then:
        - output.set_level:
            id: led_red
            level: 0.0
        - output.set_level:
            id: led_green
            level: 0.0
        - output.set_level:
            id: led_blue
            level: 0.0
        - delay: 5s
        - script.execute: spray_loop
    

esp8266:
  board: d1_mini
  restore_from_flash: true

logger:
api:
  encryption:
    key: !secret default_native_api_encryption_key
ota:
  - platform: esphome
    id: my_ota
    password: !secret default_ota_password
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Air-Freshener Fallback Hotspot"
    password: !secret fallback_ap_password
  reboot_timeout: 1.5h
  power_save_mode: NONE
captive_portal: {}


# Time from Home Assistant
time:
  - platform: homeassistant
    id: ha_time
    timezone: "Asia/Kolkata"
# Globals
globals:
  - id: spray_interval
    type: int
    restore_value: true
    initial_value: ${spray_default_interval}
  - id: time_remaining
    type: int
    restore_value: false
    initial_value: '60'

# User-adjustable spray interval
number:
  - platform: template
    name: "Spray Interval"
    id: spray_interval_number
    icon: mdi:timer
    min_value: ${spray_min_interval}
    max_value: ${spray_max_interval}
    step: ${spray_step}
    unit_of_measurement: "min"
    restore_value: True
    optimistic: True
    mode: AUTO
    on_value:
      then:
        - if:
            condition:
              lambda: return (int)x != id(spray_interval);
            then:
              - lambda: |
                  id(spray_interval) = (int)x;
                  id(time_remaining) = id(spray_interval) * 60;
              - script.execute: spray_loop


text_sensor:
# Time-until-next-spray sensor
  - platform: template
    name: "Next Spray"
    id: time_until_next_spray
    icon: mdi:timer-sand
    update_interval: ${time_update_interval}s
    lambda: |-
      if (id(is_night).state) {
        return {"Sleeping until morning"};
      } else {
        char buffer[16];
        snprintf(buffer, sizeof(buffer), "in %d sec", id(time_remaining));
        return {buffer};
      }

sensor:
# Helper lambda to detect night mode
  - platform: template
    id: is_night
    lambda: |-
      auto now = id(ha_time).now();
      // check if time is valid i.e. synced through HA
      // if time is not yet synced assume not to be night time
      if (!now.is_valid())return 0;
      return (now.hour >= ${night_start} || now.hour < ${night_end});

# Diagnostic Wi-Fi signal sensors
  - platform: wifi_signal
    name: "WiFi Signal dB"
    id: wifi_signal_db
    update_interval: 60s
    entity_category: diagnostic
  - platform: copy
    name: "WiFi Signal Percent"
    unit_of_measurement: "%"
    source_id: wifi_signal_db
    filters:
      - lambda: |-
          return min(max(2 * (x + 100.0), 0.0), 100.0);
    entity_category: diagnostic

# Spray motor output
output:
  - platform: gpio
    id: dc_motor
    pin: ${motor_pin}

# RGB LED (common-anode) via PWM for brightness control
  - platform: esp8266_pwm
    id: led_red
    pin: ${led_red_pin}
    frequency: 1000 Hz
    inverted: true
  - platform: esp8266_pwm
    id: led_green
    pin: ${led_green_pin}
    frequency: 1000 Hz
    inverted: true
  - platform: esp8266_pwm
    id: led_blue
    pin: ${led_blue_pin}
    frequency: 1000 Hz
    inverted: true

# Virtual button for triggering warning+spray cycle
button:
  - platform: template
    name: "Spray"
    icon: mdi:cloud
    id: gui_manual_spray_btn
    on_press:
      then:
        - script.execute: oneshot_spray_cycle
binary_sensor:
  - platform: gpio
    id: physical_manual_spray_btn
    pin:
      number: ${physical_manual_spray_btn_pin}
      mode:
        input: true
        pullup: true
    on_press: 
      then:
        - script.execute: oneshot_spray_cycle

# Main looping logic
script:
  - id: oneshot_spray_cycle
    mode: queued
    then:
      # stop the loop for potential clashes in timing
      - script.stop: spray_loop 
      # Warning blink: yellow
      - repeat:
          count: ${pre_spray_warning_seconds}
          then:
            - output.set_level: 
                id: led_red
                level: ${led_max_brightness}
            - output.set_level: 
                id: led_green
                level: ${led_max_brightness}
            - delay: 500ms
            - output.set_level: 
                id: led_red
                level: 0.0
            - output.set_level: 
                id: led_green
                level: 0.0
            - delay: 500ms
            - lambda: id(time_remaining)--;
      # Fast red flashes
      - repeat:
          count: ${fast_flash_count}
          then:
            - output.set_level: 
                id: led_red
                level: ${led_max_brightness}
            - delay: ${fast_flash_interval_ms}ms
            - output.set_level: 
                id: led_red
                level: 0.0
            - delay: ${fast_flash_interval_ms}ms
      # Spray action: red on + motor
      - output.set_level:
          id: led_red
          level: ${led_max_brightness}
      - output.set_level:
          id: led_green
          level: 0.0
      - output.set_level:
          id: led_blue
          level: 0.0
      - delay: 1s 
      - output.turn_on: dc_motor
      - delay: ${spray_duration_ms}ms
      - output.turn_off: dc_motor
      # Post-spray: return to green
      - output.set_level: 
          id: led_red
          level: 0.0
      - output.set_level: 
          id: led_green
          level: ${led_max_brightness}
      - output.set_level: 
          id: led_blue 
          level: 0.0
      # start the loop again
      - script.execute: spray_loop

  - id: spray_loop
    mode: restart
    then:
      - lambda: ESP_LOGD("spray_loop", "Starting countdown loop");
      # Initialize
      - lambda: id(time_remaining) = id(spray_interval) * 60;
      - if:
          condition:
            lambda: return id(ha_time).now().is_valid() && id(is_night).state;
          then:
            - lambda: ESP_LOGD("night", "Night mode active");
            # Sleeping: solid blue
            - output.set_level:
                id: led_red
                level: 0.0
            - output.set_level:
                id: led_green
                level: 0.0
            - output.set_level:
                id: led_blue
                level: ${led_max_brightness}
            - delay: 600s # 10*60 (every 10 minutes)
            - script.execute: spray_loop
          else:
            - lambda: ESP_LOGD("countdown", "Starting countdown");
            # Idle: solid green
            - output.set_level:
                id: led_red
                level: 0.0
            - output.set_level:
                id: led_green
                level: ${led_max_brightness}
            - output.set_level:
                id: led_blue
                level: 0.0
            # Countdown loop
            - while:
                condition: 
                  lambda: 'return id(time_remaining) > ${pre_spray_warning_seconds};'
                then:
                  - delay: 1s
                  - lambda: id(time_remaining)--;
                  - if:
                      condition:
                        # if countdown started before night hours but finishes during night hours
                        lambda: return id(ha_time).now().is_valid() && id(is_night).state;
                      then: 
                        # re run script to naturally go into the night hours branch
                        script.execute: spray_loop 
            - script.execute: oneshot_spray_cycle
            - script.wait: oneshot_spray_cycle
      

